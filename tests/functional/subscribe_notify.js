// TODO: 
// 1) we must convert sip.subscribe to resource.subscribe (see https://docs.yate.ro/wiki/SIP_Features_Module)
// 2) we must support resource.notify (see https://docs.yate.ro/wiki/Resource.notify)
const tl = require('tracing-log')

const { Yate, YateMessage, YateChannel } = require("next-yate");

const sip = require ('sip-lab')
const Zeq = require('@mayama/zeq')
const z = new Zeq()
const m = require('data-matching')
const sip_msg = require('sip-matching')

const extmodule = require('yate-extmodule')

var utils = require('./lib/utils.js')

let yate = new Yate({host: "127.0.0.1"});
yate.init();

const connection = extmodule.connect({host: '127.0.0.1', port: 5040}, () => {
    tl.info('connected')
})

connection.watch('call.route', (msg) => {
    tl.info('call.route')
    console.log(msg)
})

connection.watch('call.execute', (msg) => {
    tl.info('call.execute')
    console.log(msg)
})

connection.watch('chan.dtmf', (msg) => {
    z.push_event({
        event: 'chan.dtmf',
        data: msg,
    })
})

const subscriptions = {}

connection.subscribe('resource.subscribe', 50, (msg, retval) => {
    console.log('resource.subscribe')
    console.dir(msg)


})

connection.subscribe('sip.subscribe', 50, (msg, retval) => {
    console.log('sip.subscribe')
    console.dir(msg)
    //Sample: %%>message:0x7ff3d7c59900.1475523444:1639281275:sip.subscribe::called=park1:caller=user1:ip_transport=UDP:connection_id=general:connection_reliable=false:newcall=false:domain=test1.com:antiloop=19:address=127.0.0.1%z5090:ip_host=127.0.0.1:ip_port=5090:ip_transport=UDP:sip_uri=sip%zpark1@test1.com:sip_callid=28c027a3-4f31-4f9a-abf0-588b0f6ea88d:xsip_dlgtag=244984598:sip_from=<sip%zuser1@test1.com>;tag=80b44235-6ff2-4ca6-955c-21ddfefa74d5:sip_to=<sip%zuser1@test1.com>:sip_contact=<sip%zuser1@127.0.0.1%z5090>:sip_event=dialog:sip_expires=120:sip_supported=replaces, 100rel:sip_accept=application/dialog-info+xml:sip_allow-events=refer, dialog:handlers=nodejs%z50

    subscriptions[`${msg.caller}@${msg.domain}`] = msg
})

connection.subscribe('user.auth', 50, (message, result) => {
    console.log('user.auth')
    if(!message.response) {
        // since there is no message.response this is the initial REGISTER before authentication
        // I believe we should create and set a nonce in the message here.
        // but for now, we will just accept whatever we get
        return {
            processed: true,
            retval: message.number, // In our tests, the password is always the same as the SIP Username in the REGISTER (Yate reports it as 'number')
        }
    } else {
        // message.response is the authentication response generated by the user
        // I believe we should check the result based on a nonce
        return {
            processed: true,
            retval: '', // for auth success, we return ''
        }
    }
})

connection.subscribe('user.register', 50, (message, retval) => {
    console.log('user.register') 
    return true
})

connection.subscribe('user.unregister', 50, (message, retval) => {
    console.log('user.unregister') 
    return true
})


async function test() {
    await utils.hangup_all_yate_calls(yate)

    await z.sleep(1000) // wait a little because connection.subscribe() needs to complete

    const domain = 'test1.com'

    sip.dtmf_aggregation_on(500)

    sip.set_codecs("PCMU/8000/1:128")

    z.trap_events(sip.event_source, 'event', (evt) => {
        const e = evt.args[0]
        return e
    })

    console.log(sip.start((data) => { console.log(data)} ))

    const t1 = sip.transport.create({address: "127.0.0.1", port: 5090})
    const t2 = sip.transport.create({address: "127.0.0.1", port: 5092})

    console.log("t1", t1)
    console.log("t2", t2)

    const a1 = sip.account.create(t1.id, {
        domain,
        server: '127.0.0.1',
        username: 'user1',
        password: 'user1'
    })

    const a2 = sip.account.create(t1.id, {
        domain,
        server: '127.0.0.1',
        username: 'user2',
        password: 'user2'
    })

    sip.account.register(a1, {auto_refresh: true})
    sip.account.register(a2, {auto_refresh: true})

    await z.wait([
        {
            event: 'registration_status',
            account_id: a1.id,
            code: 200,
            reason: 'OK',
            expires: 60,
        },
        {
            event: 'registration_status',
            account_id: a2.id,
            code: 200,
            reason: 'OK',
            expires: 60,
        },
    ], 1000)

    const s1 = sip.subscription.create(t1.id, {
        event: 'dialog',
        accept: 'application/dialog-info+xml',
        from_uri: `<sip:user1@${domain}>`,
        to_uri: `<sip:user1@${domain}>`,
        request_uri: `sip:park1@${domain}`,
        proxy_uri: `sip:127.0.0.1`,
        auth: {
            realm: domain,
            username: 'user1',
            password: 'user1'
        }
    })

    const s2 = sip.subscription.create(t2.id, {
        event: 'dialog',
        accept: 'application/dialog-info+xml',
        from_uri: `<sip:user1@${domain}>`,
        to_uri: `<sip:user1@${domain}>`,
        request_uri: `sip:park1@${domain}`,
        proxy_uri: `sip:127.0.0.1`,
        auth: {
            realm: domain,
            username: 'user2',
            password: 'user2'
        }
    })

    sip.subscription.subscribe(s1, {expires: 120})
    sip.subscription.subscribe(s2, {expires: 120})

    await z.wait([
        {
            event: 'response',
            subscription_id: s1,
            method: 'SUBSCRIBE',
            msg: sip_msg({
                $rs: '100',
                $rr: 'Trying',
            })
        },
        {
            event: 'response',
            subscription_id: s1,
            method: 'SUBSCRIBE',
            msg: sip_msg({
                $rs: '200',
                $rr: 'OK', }) },
        {
            event: 'response',
            subscription_id: s2,
            method: 'SUBSCRIBE',
            msg: sip_msg({
                $rs: '100',
                $rr: 'Trying',
            })
        },
        {
            event: 'response',
            subscription_id: s2,
            method: 'SUBSCRIBE',
            msg: sip_msg({
                $rs: '200',
                $rr: 'OK',
            })
        },
    ], 1000)

    var subs = subscriptions[`user1@${domain}`]

    connection.dispatch('resource.notify', {
            event: 'dialog',
            expires: 120,
            notifier: `park1@${domain}`,
            subscriber: `user1@${domain}`,
            notifyto: subs.sip_contact,
            subscriptionstate: 'active',
            //data: '<dialog-info> <dialog> <state>terminated</state> <remote> <identity>sip:*40$park_position@$name_d1</identity> </remote> </dialog> </dialog-info>',
            notifyseq: 1000,
            'dialog.callid': subs.sip_callid,
            'dialog.localtag': '????',
            'dialog.remotetag': '????',
            'dialog.direction': 'outgoing',
            'dialog.remoteuri': '????',
            'dialog.state': 'terminated',
        }, (msg) => {
            console.log('resource.notify callback')
            console.dir(msg)
    })

    // the above has no effect yet.

    sip.account.unregister(a1)
    sip.account.unregister(a2)

    await z.wait([
        {
            event: 'registration_status',
            account_id: a1.id,
            code: 200,
            reason: 'OK',
            expires: 0,
        },
        {
            event: 'registration_status',
            account_id: a2.id,
            code: 200,
            reason: 'OK',
            expires: 0,
        },
    ], 1000)

    console.log("Success")

    sip.stop()
}

test()
.catch(e => {
    console.error(e)
    process.exit(1)
})

