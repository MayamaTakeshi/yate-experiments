# Yate Experiments

## Overview

This repo documents our experiments with Yate (Yet Another Telephony Engine)

We use a Dockerfile to build a docker image containing yate, sngrep2 and node.js.

The experiments are a few tests (using node.js) controlling yate via [next-yate](https://github.com/0LEG0/next-yate).

I recommend you to follow [learning-freeswitch](https://github.com/MayamaTakeshi/learning-freeswitch)

before experimenting with this.

## Build the image
```
./build_image.sh
```
## Start the container
```
./start_container.sh
```

## Starting a tmux working session
Inside the container do:
```
./tmux_session.sh
```
The above will start a tmux session as specified in tmux_session.yml.

To simplify and focus on our interests, we will have only the modules regexroute, extmodule and tonegen enabled.

## Running tests

In the tmux session switch to window 'tests/functional' and run one of the tests like this:
```
node simple.js
```

Then switch to the window 'sngrep2' and inspect the messages exchanged between the test script and yate.

Also, switch to the window 'yate' and inspect its logs.

To run all tests do:
```
./runtests
```
Obs: however, currently, test subscribe_notify.js is failing (see https://github.com/MayamaTakeshi/yate-experiments/issues/2)

## Testing with baresip

You can use baresip to listen to audio generated by yate.

The module regex route is used to determine how a call should be handled.

It is configuration is at: /usr/local/src/git/yate/conf.d/regexroute.conf 

In it you can see a list of destination number that will just generate tones:
```
MayamaTakeshi@takeshi-desktop:yate$ grep 9999 conf.d/regexroute.conf 
^99991001$=tone/dial
^99991002$=tone/busy
^99991003$=tone/ring
^99991004$=tone/specdial
^99991005$=tone/congestion
^99991006$=tone/outoforder
^99991007$=tone/milliwatt
^99991008$=tone/info
^99991010$=wave/play//usr/local/src/git/yate/audio/hello_good_morning.mulaw
```

In my ~/.baresip/accounts I have:
```
<sip:100@test1.com>;auth_pass=001;noreg
```
And to make a call to one of the above numbers I do:
```
baresip -e 'dsip:99991008@0.0.0.0:5060
```

You can also call '12345678' and the call will be handled by this javascript file:

MayamaTakeshi@takeshi-desktop:yate$ cat scripts/hello.js 
if (message.called == "12345678") {
    Channel.callTo("wave/play//usr/local/src/git/yate/audio/hello_good_morning.mulaw");
    Channel.callTo("wave/record//tmp/recording.mulaw",{"maxlen": 80000, "blocking": 1, "nosilence": 1}); // attention maxlen is not duration! It is max number of bytes to be written to file.
    Channel.callTo("wave/play//tmp/recording.mulaw");
}

This is done this way:

In conf.d/javascript we have this line:
```
routing=hello.js
```
This will instruct the javascript module to handle 'call.route' requests in case other modules with higher priority don't handle them.

So, in our case, the other module is regexroute, and since the number '12345678' doesn't get matched by regexroute.conf, the javascript module has the chance to process it.

## Yate Javascript

### Some gotchas

Do not use code like this:
```
if(message.called != '12345678') {
  return
}
Channel.callTo("wave/play//usr/local/src/git/yate/audio/hello_good_morning.mulaw");
```

The above will not work. I don't know why.

Instead, do:
```
if(message.called == '12345678') {
  Channel.callTo("wave/play//usr/local/src/git/yate/audio/hello_good_morning.mulaw");
}
```

Channel.callTo("wave/play//usr/local/src/git/yate/audio/hello_good_morning.mulaw");
`

## BeF's Yate Cookbook

Some good tips here:

https://github.com/bef/yate-cookbook

## Convert audio files to format usable by yate

Yate cannot handle wav files so you need to convert to a format like mulaw:

```
sox hello.wav -t raw -r 8000 -e mu-law -b 8 hello.mulaw
```

## Watching messages

In the telnet window issue ths command:
```
sniffer on
```

This will make yate output things (in the yate window) like this:
```
2025-09-19_16:09:38.504166 Sniffed 'user.auth' time=1758265778.504132 age=0.000025
  thread=0x64c61c86a350 'YSIP EndPoint'
  data=(nil)
  retval='(null)'
  param['protocol'] = 'sip'
  param['method'] = 'INVITE'
  param['uri'] = 'sip:1234@0.0.0.0'
  param['ip_host'] = '192.168.0.113'
  param['ip_port'] = '49408'
  param['ip_transport'] = 'UDP'
  param['address'] = '192.168.0.113:49408'
  param['connection_id'] = 'general'
  param['connection_reliable'] = 'false'
  param['newcall'] = 'true'
  param['domain'] = 'test1.com'
  param['device'] = 'baresip v3.7.0 (x86_64/Linux)'
  param['id'] = 'sip/5'
  param['caller'] = '100'
  param['called'] = '1234'
  param['billid'] = '1758265039-9'
2025-09-19_16:09:38.504247 Returned false 'user.auth' delay=0.000097
  thread=0x64c61c86a350 'YSIP EndPoint'
  data=(nil)
  retval='(null)'
  param['protocol'] = 'sip'
  param['method'] = 'INVITE'
  param['uri'] = 'sip:1234@0.0.0.0'
  param['ip_host'] = '192.168.0.113'
  param['ip_port'] = '49408'
  param['ip_transport'] = 'UDP'
  param['address'] = '192.168.0.113:49408'
  param['connection_id'] = 'general'
  param['connection_reliable'] = 'false'
  param['newcall'] = 'true'
  param['domain'] = 'test1.com'
  param['device'] = 'baresip v3.7.0 (x86_64/Linux)'
  param['id'] = 'sip/5'
  param['caller'] = '100'
  param['called'] = '1234'
  param['billid'] = '1758265039-9'
  param['handlers'] = 'monitoring:1,regfile:100'
```


