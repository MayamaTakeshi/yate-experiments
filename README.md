# Yate Experiments

## Overview

This repo documents our experiments with Yate (Yet Another Telephony Engine)

We use a Dockerfile to build a docker image containing yate, sngrep2, node.js and sipp.

The experiments are a few tests (using node.js) controlling yate via [next-yate](https://github.com/0LEG0/next-yate) or via ([yate-extmodule](https://github.com/latysheff/node-yate-extmodule)

I recommend you to follow [learning-freeswitch](https://github.com/MayamaTakeshi/learning-freeswitch) before experimenting with this.

You might also like to take a look at: https://docs.yate.ro/wiki/Main_Page

## Build the image
```
./build_image.sh
```
## Start the container
```
./start_container.sh
```

## Starting a tmux working session
Inside the container do:
```
./tmux_session.sh
```
The above will start a tmux session as specified in tmux_session.yml.

To simplify and focus on our interests, we will have only the modules regexroute, extmodule and javascript enabled.

## Running tests

In the tmux session switch to window 'tests/functional' and run one of the tests like this:
```
node echo_test.js
```

Then switch to the window 'sngrep2' and inspect the messages exchanged between the test script and yate.

Also, switch to the window 'yate' and inspect its logs.

To run all tests do:
```
./runtests -r
```
Sample execution:
```
MayamaTakeshi@takeshi-desktop:functional$ ./runtests -r
... ABRIDGED ...
wait (subscribe_notify.js:170) timed out
subscribe_notify.js failed

Finished:

Successful tests:
  - echo_test.js
  - handling.call.route.js
  - media_functions.js
  - media_functions_with_callto_callbacks.js
  - outgoing_call.js
  - receive_fax.js
  - register_and_invite.js
  - send_fax.js

Failed tests:
  - subscribe_notify.js

MayamaTakeshi@takeshi-desktop:functional$ 
```
The '-r' option mean to run in report mode (run all tests and report the results).

But during work, you might want to stop at the first error. 

For this, just use:
```
./runtests
```
There is also option -f which permits to run the tests starting from a specific one:
```
./runtests -f outgoing_call.js
```

Obs:currently, test subscribe_notify.js is failing (see https://github.com/MayamaTakeshi/yate-experiments/issues/2)

Quick description of the test scripts:

- echo_test.js: shows how to concatenate a list of media commands using next-yate facilities.
- handling.call.route.js: show how to watch for 'call.route' msg to wait for incoming call and send the call to another sip endpoint.
- media_functions.js: shows how to handle media events step-by-step instead of concatenating all media commands (counter-example of echo_test.js).
- media_functions_with_callto_callbacks.js: similar to media_functions.js but pushing events from next_wait callTo callbacks.
- outgoing_call.js: shows how to originate an outgoing call from within yate (for example, for click2call implementation).
- receive_fax.js: receives a fax from yate.
- register_and_invite.js: shows how to SIP REGISTER a SIP UA and make a call to it
- send_fax.js: sends a fax to yate.
- subscribe_notify.js: (not working). it was suppose to show how to do a SIP SUBSCRIBE and get a SIP NOTIFY from yate.

## Testing with baresip

You can use baresip to listen to audio generated by yate.

The module regex route is used to determine how a call should be handled.

It is configuration is at: /usr/local/src/git/yate/conf.d/regexroute.conf 

In it you can see a list of destination number for tests:
```
$ grep 9999 conf.d/regexroute.conf 
^99991001$=tone/dial
^99991002$=tone/busy
^99991003$=tone/ring
^99991004$=tone/specdial
^99991005$=tone/congestion
^99991006$=tone/outoforder
^99991007$=tone/milliwatt
^99991008$=tone/info
^99991010$=wave/play//usr/local/src/git/yate/media/hello_good_morning.mulaw
^99991011$=fax/transmit//usr/local/src/git/yate/media/sample.tiff
^99991012$=fax/receive//tmp/received.tiff
```

In my ~/.baresip/accounts I have:
```
<sip:100@test1.com>;auth_pass=001;noreg
```
And to make a call to one of the above numbers I do:
```
baresip -e 'dsip:99991008@0.0.0.0:5060
```

You can also call '12345678' and the call will be handled by this javascript file:
```
MayamaTakeshi@takeshi-desktop:yate$ cat scripts/hello.js 
if (message.called == "12345678") {
    Channel.callTo("wave/play//usr/local/src/git/yate/media/hello_good_morning.mulaw");
    Channel.callTo("wave/record//tmp/recording.mulaw",{"maxlen": 80000, "blocking": 1}); // attention maxlen is not duration! It is max number of bytes to be written to file.
    Channel.callTo("wave/play//tmp/recording.mulaw");
}
```
This is done this way:

In conf.d/javascript we have this line:
```
routing=routing.js
```
This will instruct the javascript module to handle 'call.route' messages using scripts/routing.js.

This message (generated by the sip module) is asking if some module knows how to route this call. 

Basically, 'to route' means, what to do with this call, like playing a message, sending to another sip endpoint etc.

If we don't handle some called number in routing.js, some other module will have the chance to try to handle them. In our case, the module will be regexroute and so it will handled 99991001 etc.

## Yate Javascript

### Some gotchas

Do not use code like this:
```
if(message.called != '12345678') {
  return
}
Channel.callTo("wave/play//usr/local/src/git/yate/media/hello_good_morning.mulaw");
```

The above will not work. I don't know why.

Instead, do:
```
if(message.called == '12345678') {
  Channel.callTo("wave/play//usr/local/src/git/yate/median/hello_good_morning.mulaw");
}
```

## BeF's Yate Cookbook

Some good tips here:

https://github.com/bef/yate-cookbook

## Convert audio files to format usable by yate

Yate cannot handle wav files so you need to convert to a format like mulaw:

```
sox hello.wav -t raw -r 8000 -e mu-law -b 8 hello.mulaw
```
You can do this more comfortably using the script wav_to_mulaw.sh:
```
$ ./wav_to_mulaw.sh dtmf.123.wav
Success: file dtmf.123.wav.mulaw was craeted.
```

## Watching messages

In the telnet window issue ths command:
```
sniffer on
```

This will make yate output things (in the yate window) like this:
```
2025-09-19_16:09:38.504166 Sniffed 'user.auth' time=1758265778.504132 age=0.000025
  thread=0x64c61c86a350 'YSIP EndPoint'
  data=(nil)
  retval='(null)'
  param['protocol'] = 'sip'
  param['method'] = 'INVITE'
  param['uri'] = 'sip:1234@0.0.0.0'
  param['ip_host'] = '192.168.0.113'
  param['ip_port'] = '49408'
  param['ip_transport'] = 'UDP'
  param['address'] = '192.168.0.113:49408'
  param['connection_id'] = 'general'
  param['connection_reliable'] = 'false'
  param['newcall'] = 'true'
  param['domain'] = 'test1.com'
  param['device'] = 'baresip v3.7.0 (x86_64/Linux)'
  param['id'] = 'sip/5'
  param['caller'] = '100'
  param['called'] = '1234'
  param['billid'] = '1758265039-9'
2025-09-19_16:09:38.504247 Returned false 'user.auth' delay=0.000097
  thread=0x64c61c86a350 'YSIP EndPoint'
  data=(nil)
  retval='(null)'
  param['protocol'] = 'sip'
  param['method'] = 'INVITE'
  param['uri'] = 'sip:1234@0.0.0.0'
  param['ip_host'] = '192.168.0.113'
  param['ip_port'] = '49408'
  param['ip_transport'] = 'UDP'
  param['address'] = '192.168.0.113:49408'
  param['connection_id'] = 'general'
  param['connection_reliable'] = 'false'
  param['newcall'] = 'true'
  param['domain'] = 'test1.com'
  param['device'] = 'baresip v3.7.0 (x86_64/Linux)'
  param['id'] = 'sip/5'
  param['caller'] = '100'
  param['called'] = '1234'
  param['billid'] = '1758265039-9'
  param['handlers'] = 'monitoring:1,regfile:100'
```

## How to get active calls in the system

By testing with telnet connection we verified that if we enable sniffer:
```
sniffer on
```
and send
```
status cdrbuild
```
yate will output something like this:
```
2025-09-20_13:50:11.563601 Sniffed 'engine.status' time=1758343811.563558 age=0.000027
  thread=0x7e9ba8000c30 'RManager Connection'
  data=(nil)
  retval='(null)'
  param['module'] = 'cdrbuild'
  param['cmd_address'] = '127.0.0.1:46836'
  param['cmd_machine'] = 'false'
  param['cmd_width'] = '229'
  param['cmd_height'] = '58'
  param['cmd_admin'] = 'true'
2025-09-20_13:50:11.563910 Returned false 'engine.status' delay=0.000340
  thread=0x7e9ba8000c30 'RManager Connection'
  data=(nil)
  retval='name=cdrbuild,type=cdr,format=Status|Caller|Called|BillId|Duration;cdrs=0,hungup=0;
'
  param['module'] = 'cdrbuild'
  param['cmd_address'] = '127.0.0.1:46836'
  param['cmd_machine'] = 'false'
  param['cmd_width'] = '229'
  param['cmd_height'] = '58'
yate.output("Hello World!");
  param['cmd_admin'] = 'true'
  param['handlers'] = 'engine:90,callgen:100,moh:100,cdrcombine:100,rex_debug:100,g722webrtc:100,isaccodec:100,cdrbuild:100,ilbcwebrtc:100,accfile:100,regfile:100,jbfeatures:110,jabber:110,analogdetect:110,sigtransport:110,subscription:110,mgcpca:110,hep3_capture:110,ciscosm:110,mux:110,openssl:110,javascript:110,socks:110,zlibcompress:110,gvoice:110,sip:110,analyzer:110,tone:110,extmodule:110,callfork:110,fileinfo:110,stun:110,iax:110,enumroute:110,regexroute:110,pbx:110,dumb:110,jingle:110,wave:110,yrtp:110,tonedetect:110,conf:110,filetransfer:110,analog:110,sig:110,snmpagent:110,mgcpgw:110,queuesnotify:110,queues:110,cache:110,mrcp:110,users:110,presence:110,monitoring:110,register:110,park:110,sipfeatures:110'
```
So the message was catched by module cdrbuild than then reported the results.

It informed a list of active calls in the retval.

In this case there were no active calls.

Then I executed a test creating a leg1/leg2 call and while it was alive I executed this node.js script:
```
$ cat a.js 
const {Yate, YateMessage} = require("next-yate");
let yate = new Yate({host: "127.0.0.1", trackname: "myscript"});
yate.init();
yate.output("Hello World!");

let m = new YateMessage('engine.status', {module: 'cdrbuild'});
yate.dispatch(m)
.then((msg) => {
    console.log(msg._retvalue)
})

$ node a.js 
name=cdrbuild,type=cdr,format=Status|Caller|Called|BillId|Duration;cdrs=2,hungup=0;sip/5=incoming|user1|user2|1758343601-3|3,sip/6=outgoing|user1|user2|1758343601-3|3
```
We confirmed the above in the yate output:

This caused yate to output:
```
2025-09-20_14:34:10.543018 <extmodule:INFO> Listener 'sample' got connection from '127.0.0.1:37784'                                                                                                                                  
2025-09-20_14:34:10.543046 <extmodule:ALL> ExtModChan[sample] args='127.0.0.1:37784' io=(0x7e9ba00030d0) chan=((nil)) created [0x7e9ba0003110]                                                                                       
2025-09-20_14:34:11.047319 Hello World!                                                                           
2025-09-20_14:34:11.047460 Sniffed 'engine.status' time=1758346450.000000 age=1.047454
  thread=0x5c7d83950020 'Engine Worker'
  data=(nil)
  retval='(null)'
  param['module'] = 'cdrbuild'
2025-09-20_14:34:11.047617 Returned false 'engine.status' delay=1.047615
  thread=0x5c7d83950020 'Engine Worker'
  data=(nil)
  retval='name=cdrbuild,type=cdr,format=Status|Caller|Called|BillId|Duration;cdrs=2,hungup=0;sip/5=incoming|user1|user2|1758343601-3|3,sip/6=outgoing|user1|user2|1758343601-3|3
'
  param['module'] = 'cdrbuild'
  param['handlers'] = 'engine:90,callgen:100,moh:100,cdrcombine:100,rex_debug:100,g722webrtc:100,isaccodec:100,cdrbuild:100,ilbcwebrtc:100,accfile:100,regfile:100,jbfeatures:110,jabber:110,analogdetect:110,sigtransport:110,subscr
iption:110,mgcpca:110,hep3_capture:110,ciscosm:110,mux:110,openssl:110,javascript:110,socks:110,zlibcompress:110,gvoice:110,sip:110,analyzer:110,tone:110,extmodule:110,callfork:110,fileinfo:110,stun:110,iax:110,enumroute:110,rege
xroute:110,pbx:110,dumb:110,jingle:110,wave:110,yrtp:110,tonedetect:110,conf:110,filetransfer:110,analog:110,sig:110,snmpagent:110,mgcpgw:110,queuesnotify:110,queues:110,cache:110,mrcp:110,users:110,presence:110,monitoring:110,re
gister:110,park:110,sipfeatures:110'

```
For completeness here is the ngrep output showing the low level yate protocol messages:
```
$ sudo ngrep -d any -q -W byline 'cdrbuild' 
interface any
filter: (ip || ip6)
match: cdrbuild


T 127.0.0.1:37784 -> 127.0.0.1:5040 [AP] #40472
%%>message:1758346450.81922459:1758346450:engine.status::module=cdrbuild


T 127.0.0.1:5040 -> 127.0.0.1:37784 [AP] #40482
%%<message:1758346450.81922459:false:engine.status:name=cdrbuild,type=cdr,format=Status|Caller|Called|BillId|Duration;cdrs=2,hungup=0;sip/5=incoming|user1|user2|1758343601-3|3,sip/6=outgoing|user1|user2|1758343601-3|3%M%J:module=cdrbuild:handlers=engine%z90,callgen%z100,moh%z100,cdrcombine%z100,rex_debug%z100,g722webrtc%z100,isaccodec%z100,cdrbuild%z100,ilbcwebrtc%z100,accfile%z100,regfile%z100,jbfeatures%z110,jabber%z110,analogdetect%z110,sigtransport%z110,subscription%z110,mgcpca%z110,hep3_capture%z110,ciscosm%z110,mux%z110,openssl%z110,javascript%z110,socks%z110,zlibcompress%z110,gvoice%z110,sip%z110,analyzer%z110,tone%z110,extmodule%z110,callfork%z110,fileinfo%z110,stun%z110,iax%z110,enumroute%z110,regexroute%z110,pbx%z110,dumb%z110,jingle%z110,wave%z110,yrtp%z110,tonedetect%z110,conf%z110,filetransfer%z110,analog%z110,sig%z110,snmpagent%z110,mgcpgw%z110,queuesnotify%z110,queues%z110,cache%z110,mrcp%z110,users%z110,presence%z110,monitoring%z110,register%z110,park%z110,sipfeatures%z110
```

So we can see the 2 cdrs (channels).
The important thing in them is the channel id ("sip/5", "sip/6") that can be used to issue exiternal commands like 'call.drop' (we need this for example to terminate all calls that might remain
alive in yate after a failed test).

## TODO

- The experiments (tests/functional/*.js files) likely are watching all messages for all calls in the system. Since this is for testing and learning, this is OK. But in a production system we would not use this and
more likely would ask yate to restrict notification for specific channels we are handling in the script.

## Findings

### dead calls

while load testing with sipp, the test was terminated without sending BYE to the calls and these calls stayed in the 'status cdrbuild' output. 
So these are dead calls. The sipp scenarios don't use session timers and so probably these callwill stay in yate memory forever.
This might not happen in prod as we probably have session timers there but this is not critical because we can just remove such calls periodicaly using msg 'call.drop'.

### drop calls
Uot tested yet but it seems we can drop calls using the telnet connection as its help shows: drop {chan|*|all} [reason]

### MRCP support:
```
2025-09-21_07:44:59.467847 <ALL> Plugin::Plugin("mrcp",false) [0x75340b37d280]
2025-09-21_07:44:59.467862 Loaded module MRCP
```
So the module is built but the mrcp.conf.sample is nowhere to be found. So if this actually works, we would need to get configuration detail from source code.

### Python module

But I have not tested it: https://github.com/eventphone/python-yate
