# Yate Experiments

## Overview

This repo documents our experiments with Yate (Yet Another Telephony Engine).

We use a Dockerfile to build a docker image containing yate, sngrep2, node.js and sipp.

The experiments are a few tests (using node.js) controlling yate via [next-yate](https://github.com/0LEG0/next-yate) or via [yate-extmodule](https://github.com/latysheff/node-yate-extmodule)

I recommend you to follow [learning-freeswitch](https://github.com/MayamaTakeshi/learning-freeswitch) before experimenting with this.

You might also want to take a look at: https://docs.yate.ro/wiki/Beginners_in_Yate

(the information is outdated but the basics didn't change).

## Build the image
```
./build_image.sh
```
## Start the container
```
./start_container.sh
```

## Starting a tmux working session
Inside the container do:
```
./tmux_session.sh
```
The above will start a tmux session as specified in tmux_session.yml.

You will yave the following windows:
  - yate: yate running and outputting logs
  - sngrep2: sip msg flow visualizer
  - tests: bash opened at the tests/functional folder
  - rmanager: telnet connected to yate to permit to send commands to it (https://docs.yate.ro/wiki/Rmanager)

To simplify and focus on our interests, we will have only the modules regexroute, extmodule, faxchan and javascript enabled.

## Running tests

In the tmux session switch to window 'tests/functional' and run one of the tests like this:
```
node echo_test.js
```

Then switch to the window 'sngrep2' and inspect the messages exchanged between the test script and yate.

Also, switch to the window 'yate' and inspect its logs.

To run all tests do:
```
./runtests -r
```
Sample execution:
```
MayamaTakeshi@takeshi-desktop:functional$ ./runtests -r
... ABRIDGED ...
wait (subscribe_notify.js:170) timed out
subscribe_notify.js failed

Finished:

Successful tests:
  - echo_test.js
  - handling.call.route.js
  - media_functions.js
  - media_functions_with_callto_callbacks.js
  - outgoing_call.js
  - receive_fax.js
  - register_and_invite.js
  - send_fax.js

Failed tests:
  - subscribe_notify.js

MayamaTakeshi@takeshi-desktop:functional$ 
```
The '-r' option mean to run in report mode (run all tests and report the results).

But during work, you might want to stop at the first error. 

For this, just use:
```
./runtests
```
There is also option -f which permits to run the tests starting from a specific one:
```
./runtests -f outgoing_call.js
```

Obs: currently, the test subscribe_notify.js is failing (see https://github.com/MayamaTakeshi/yate-experiments/issues/2)

Quick description of the test scripts:

- echo_test.js: shows how to concatenate a list of media commands using next-yate facilities.
- handling.call.route.js: shows how to watch for 'call.route' msg to wait for incoming call and send the call to another sip endpoint.
- media_functions.js: shows how to handle media events step-by-step instead of concatenating all media commands (counter-example of echo_test.js).
- media_functions_with_callto_callbacks.js: similar to media_functions.js but pushing events from next_wait callTo callbacks.
- outgoing_call.js: shows how to originate an outgoing call from within yate (for example, for click2call implementation).
- receive_fax.js: receives a fax from yate.
- register_and_invite.js: shows how to SIP REGISTER a SIP UA and make a call to it
- send_fax.js: sends a fax to yate.
- subscribe_notify.js: (not working). It was suppose to show how to do a SIP SUBSCRIBE and get a SIP NOTIFY from yate.

## Testing with baresip

You can use baresip to listen to audio generated by yate.

The module regex route is used to determine how a call should be handled.

It configuration is at: /usr/local/src/git/yate/conf.d/regexroute.conf 

In it you can see a list of destination number for tests:
```
$ grep 9999 conf.d/regexroute.conf 
^99991001$=tone/dial
^99991002$=tone/busy
^99991003$=tone/ring
^99991004$=tone/specdial
^99991005$=tone/congestion
^99991006$=tone/outoforder
^99991007$=tone/milliwatt
^99991008$=tone/info
^99991010$=wave/play//usr/local/src/git/yate/media/hello_good_morning.mulaw
^99991011$=fax/transmit//usr/local/src/git/yate/media/sample.tiff
^99991012$=fax/receive//tmp/received.tiff
```

In my ~/.baresip/accounts I have:
```
<sip:100@test1.com>;auth_pass=001;noreg
```
And to make a call to one of the above numbers I do:
```
baresip -e 'dsip:99991008@0.0.0.0:5060'
```

You can also call '12345678' and the call will be handled by this javascript file:
```
takeshi@takeshi-desktop:yate-experiments$ cat scripts/routing.js 
if (message.called == "12345678") {
    Channel.callTo("wave/play//usr/local/src/git/yate/media/hello_good_morning.mulaw");
    Channel.callTo("wave/record//tmp/recording." + message.billid + ".mulaw",{"maxlen": 80000}); // attention maxlen is not duration! It is max number of bytes to be written to file.
    Channel.callTo("wave/play//tmp/recording." + message.billid + ".mulaw");
} else if (message.called == "11112222") {
    Channel.callTo("wave/play//usr/local/src/git/yate/media/hello_good_morning.mulaw");
} else if (message.called == "33334444") {
    Channel.callTo("sip/sip:33334444@127.0.0.1:5070");
}
```
This is done this way:

In conf.d/javascript we have this line:
```
routing=routing.js
```
This will instruct the javascript module to handle 'call.route' messages using scripts/routing.js. This is done by subscribing to this msg to the yate engine.

This message (generated by the sip module) is asking if some module knows how to route this call. The message is offered to each module interested in it based on priority specified during subscription.

So the javascript module gets it first because using "routing=" subscribes to "call.route" with high priority.

Basically, 'to route' means, what to do with this call, like playing a message, sending to another sip endpoint etc.

If we don't handle some call in routing.js, some other module will have the chance to try to handle it. 

In our case, the next module will be regexroute and so it will handle 99991001 etc.

## Yate Javascript

The javascript interpreter is very old. You cannot use modern things like
```
var s = `this is ${somevar}`
```
And expression must always end with ';'.

Check the yate output for things like this indicating errors:
```
2025-09-22_08:40:37.085364 Initializing module Javascript
2025-09-22_08:40:37.085607 <javascript:WARN> Failed to parse script: /usr/local/src/git/yate/scripts/routing.js
```

## Convert audio files to format usable by yate

Yate cannot handle wav files so you need to convert to a format like mulaw:

```
sox hello.wav -t raw -r 8000 -e mu-law -b 8 hello.mulaw
```
You can do this more comfortably using the script wav_to_mulaw.sh:
```
$ ./wav_to_mulaw.sh dtmf.123.wav
Success: file dtmf.123.wav.mulaw was craeted.
```

## Watching messages

In the rmanager window issue ths command:
```
sniffer on
```

This will make yate output things (in the yate window) like these:
```
2025-09-19_16:09:38.504166 Sniffed 'user.auth' time=1758265778.504132 age=0.000025
  thread=0x64c61c86a350 'YSIP EndPoint'
  data=(nil)
  retval='(null)'
  param['protocol'] = 'sip'
  param['method'] = 'INVITE'
  param['uri'] = 'sip:1234@0.0.0.0'
  param['ip_host'] = '192.168.0.113'
  param['ip_port'] = '49408'
  param['ip_transport'] = 'UDP'
  param['address'] = '192.168.0.113:49408'
  param['connection_id'] = 'general'
  param['connection_reliable'] = 'false'
  param['newcall'] = 'true'
  param['domain'] = 'test1.com'
  param['device'] = 'baresip v3.7.0 (x86_64/Linux)'
  param['id'] = 'sip/5'
  param['caller'] = '100'
  param['called'] = '1234'
  param['billid'] = '1758265039-9'
2025-09-19_16:09:38.504247 Returned false 'user.auth' delay=0.000097
  thread=0x64c61c86a350 'YSIP EndPoint'
  data=(nil)
  retval='(null)'
  param['protocol'] = 'sip'
  param['method'] = 'INVITE'
  param['uri'] = 'sip:1234@0.0.0.0'
  param['ip_host'] = '192.168.0.113'
  param['ip_port'] = '49408'
  param['ip_transport'] = 'UDP'
  param['address'] = '192.168.0.113:49408'
  param['connection_id'] = 'general'
  param['connection_reliable'] = 'false'
  param['newcall'] = 'true'
  param['domain'] = 'test1.com'
  param['device'] = 'baresip v3.7.0 (x86_64/Linux)'
  param['id'] = 'sip/5'
  param['caller'] = '100'
  param['called'] = '1234'
  param['billid'] = '1758265039-9'
  param['handlers'] = 'monitoring:1,regfile:100'
```

so it should be easy to understand how yate message architecture works (but log of decisions could be better).

## How to get active calls in the system

In yate, there is a module called cdrbuild that monitors calls.

In the rmanager window (remember to input 'sniffer on' to see msgs in the yate output) you can input 'status cdrbuild' and will get cdr info:

```
status cdrbuild
%%+status:cdrbuild
name=cdrbuild,type=cdr,format=Status|Caller|Called|BillId|Duration;cdrs=28,hungup=2;sip/270183=answered|0311112222|33334444|1758415336-405210|33,sip/270184=answered|0311112222|33334444|1758415336-405210|33,sip/270189=answered|0311112222|33334444|1758415336-405219|32,sip/270190=answered|0311112222|33334444|1758415336-405219|32,sip/270195=answered|0311112222|33334444|1758415336-405228|32,sip/270196=answered|0311112222|33334444|1758415336-405228|32,sip/270221=answered|0311112222|99991001|1758415336-405265|30,sip/270233=answered|0311112222|99991001|1758415336-405283|29,sip/270237=answered|0311112222|33334444|1758415336-405291|28,sip/270238=answered|0311112222|33334444|1758415336-405291|28,sip/270239=answered|0311112222|99991001|1758415336-405292|28,sip/270240=answered|0311112222|99991008|1758415336-405294|28,sip/270243=answered|0311112222|33334444|1758415336-405300|28,sip/270244=answered|0311112222|33334444|1758415336-405300|28,sip/270245=answered|0311112222|99991001|1758415336-405301|28,sip/270246=answered|0311112222|99991008|1758415336-405303|28,sip/270251=answered|0311112222|99991001|1758415336-405310|27,sip/270252=answered|0311112222|99991008|1758415336-405312|27,sip/270258=answered|0311112222|99991008|1758415336-405321|27,sip/270263=answered|0311112222|99991001|1758415336-405328|26,sip/270264=answered|0311112222|99991008|1758415336-405330|26,sip/270269=answered|0311112222|99991001|1758415336-405337|26,sip/270270=answered|0311112222|99991008|1758415336-405339|26,sip/270275=answered|0311112222|99991001|1758415336-405346|25,sip/270276=answered|0311112222|99991008|1758415336-405348|25,sip/270284=answered|0311112222|99991001|1758415336-405358|20,sip/270285=answered|0311112222|99991008|1758415336-405360|20,sip/270290=answered|0311112222|99991001|1758415336-405367|20
%%-status
```
In the above we can see the response (using yate text based msg protocol). We can see there are 28 active calls (cdrs=28) we can see details of each such calls.

Looking at the yate output we will see something like this:

```
2025-09-20_13:50:11.563601 Sniffed 'engine.status' time=1758343811.563558 age=0.000027
  thread=0x7e9ba8000c30 'RManager Connection'
  data=(nil)
  retval='(null)'
  param['module'] = 'cdrbuild'
  param['cmd_address'] = '127.0.0.1:46836'
  param['cmd_machine'] = 'false'
  param['cmd_width'] = '229'
  param['cmd_height'] = '58'
  param['cmd_admin'] = 'true'
2025-09-20_13:50:11.563910 Returned false 'engine.status' delay=0.000340
  thread=0x7e9ba8000c30 'RManager Connection'
  data=(nil)
  retval='name=cdrbuild,type=cdr,format=Status|Caller|Called|BillId|Duration;cdrs=28,hungup=2;sip/270183=answered|0311112222|33334444|1758415336-405210|33,sip/270184=answered|0311112222|33334444|1758415336-405210|33,sip/270189=answered|0311112222|33334444|1758415336-405219|32,sip/270190=answered|0311112222|33334444|1758415336-405219|32,sip/270195=answered|0311112222|33334444|1758415336-405228|32,sip/270196=answered|0311112222|33334444|1758415336-405228|32,sip/270221=answered|0311112222|99991001|1758415336-405265|30,sip/270233=answered|0311112222|99991001|1758415336-405283|29,sip/270237=answered|0311112222|33334444|1758415336-405291|28,sip/270238=answered|0311112222|33334444|1758415336-405291|28,sip/270239=answered|0311112222|99991001|1758415336-405292|28,sip/270240=answered|0311112222|99991008|1758415336-405294|28,sip/270243=answered|0311112222|33334444|1758415336-405300|28,sip/270244=answered|0311112222|33334444|1758415336-405300|28,sip/270245=answered|0311112222|99991001|1758415336-405301|28,sip/270246=answered|0311112222|99991008|1758415336-405303|28,sip/270251=answered|0311112222|99991001|1758415336-405310|27,sip/270252=answered|0311112222|99991008|1758415336-405312|27,sip/270258=answered|0311112222|99991008|1758415336-405321|27,sip/270263=answered|0311112222|99991001|1758415336-405328|26,sip/270264=answered|0311112222|99991008|1758415336-405330|26,sip/270269=answered|0311112222|99991001|1758415336-405337|26,sip/270270=answered|0311112222|99991008|1758415336-405339|26,sip/270275=answered|0311112222|99991001|1758415336-405346|25,sip/270276=answered|0311112222|99991008|1758415336-405348|25,sip/270284=answered|0311112222|99991001|1758415336-405358|20,sip/270285=answered|0311112222|99991008|1758415336-405360|20,sip/270290=answered|0311112222|99991001|1758415336-405367|20
'
  param['module'] = 'cdrbuild'
  param['cmd_address'] = '127.0.0.1:46836'
  param['cmd_machine'] = 'false'
  param['cmd_width'] = '229'
  param['cmd_height'] = '58'
  param['cmd_admin'] = 'true'
  param['handlers'] = 'engine:90,callgen:100,moh:100,cdrcombine:100,rex_debug:100,g722webrtc:100,isaccodec:100,cdrbuild:100,ilbcwebrtc:100,accfile:100,regfile:100,jbfeatures:110,jabber:110,analogdetect:110,sigtransport:110,subscription:110,mgcpca:110,hep3_capture:110,ciscosm:110,mux:110,openssl:110,javascript:110,socks:110,zlibcompress:110,gvoice:110,sip:110,analyzer:110,tone:110,extmodule:110,callfork:110,fileinfo:110,stun:110,iax:110,enumroute:110,regexroute:110,pbx:110,dumb:110,jingle:110,wave:110,yrtp:110,tonedetect:110,conf:110,filetransfer:110,analog:110,sig:110,snmpagent:110,mgcpgw:110,queuesnotify:110,queues:110,cache:110,mrcp:110,users:110,presence:110,monitoring:110,register:110,park:110,sipfeatures:110'
```

So basically inputting 'status cdrbuild' sends msg 'engine.status' with param 'module' == 'cdrbuild.

Then the module cdrbuild intercepts this message and sends back its status.

Then, after a restart of yate, I executed a test creating a leg1/leg2 call and while it was alive I executed this node.js script:
```
$ cat a.js 
const {Yate, YateMessage} = require("next-yate");
let yate = new Yate({host: "127.0.0.1", trackname: "myscript"});
yate.init();
yate.output("Hello World!");

let m = new YateMessage('engine.status', {module: 'cdrbuild'});
yate.dispatch(m)
.then((msg) => {
    console.log(msg._retvalue)
})

$ node a.js 
name=cdrbuild,type=cdr,format=Status|Caller|Called|BillId|Duration;cdrs=2,hungup=0;sip/5=incoming|user1|user2|1758343601-3|3,sip/6=outgoing|user1|user2|1758343601-3|3
```
We confirmed the above in the yate output:

This caused yate to output:
```
2025-09-20_14:34:10.543018 <extmodule:INFO> Listener 'sample' got connection from '127.0.0.1:37784'                                                                                                                                  
2025-09-20_14:34:10.543046 <extmodule:ALL> ExtModChan[sample] args='127.0.0.1:37784' io=(0x7e9ba00030d0) chan=((nil)) created [0x7e9ba0003110]                                                                                       
2025-09-20_14:34:11.047319 Hello World!                                                                           
2025-09-20_14:34:11.047460 Sniffed 'engine.status' time=1758346450.000000 age=1.047454
  thread=0x5c7d83950020 'Engine Worker'
  data=(nil)
  retval='(null)'
  param['module'] = 'cdrbuild'
2025-09-20_14:34:11.047617 Returned false 'engine.status' delay=1.047615
  thread=0x5c7d83950020 'Engine Worker'
  data=(nil)
  retval='name=cdrbuild,type=cdr,format=Status|Caller|Called|BillId|Duration;cdrs=2,hungup=0;sip/5=incoming|user1|user2|1758343601-3|3,sip/6=outgoing|user1|user2|1758343601-3|3
'
  param['module'] = 'cdrbuild'
  param['handlers'] = 'engine:90,callgen:100,moh:100,cdrcombine:100,rex_debug:100,g722webrtc:100,isaccodec:100,cdrbuild:100,ilbcwebrtc:100,accfile:100,regfile:100,jbfeatures:110,jabber:110,analogdetect:110,sigtransport:110,subscr
iption:110,mgcpca:110,hep3_capture:110,ciscosm:110,mux:110,openssl:110,javascript:110,socks:110,zlibcompress:110,gvoice:110,sip:110,analyzer:110,tone:110,extmodule:110,callfork:110,fileinfo:110,stun:110,iax:110,enumroute:110,rege
xroute:110,pbx:110,dumb:110,jingle:110,wave:110,yrtp:110,tonedetect:110,conf:110,filetransfer:110,analog:110,sig:110,snmpagent:110,mgcpgw:110,queuesnotify:110,queues:110,cache:110,mrcp:110,users:110,presence:110,monitoring:110,re
gister:110,park:110,sipfeatures:110'

```
For completeness here is the ngrep output showing the low level yate protocol messages:
```
$ sudo ngrep -d any -q -W byline 'cdrbuild' 
interface any
filter: (ip || ip6)
match: cdrbuild


T 127.0.0.1:37784 -> 127.0.0.1:5040 [AP] #40472
%%>message:1758346450.81922459:1758346450:engine.status::module=cdrbuild


T 127.0.0.1:5040 -> 127.0.0.1:37784 [AP] #40482
%%<message:1758346450.81922459:false:engine.status:name=cdrbuild,type=cdr,format=Status|Caller|Called|BillId|Duration;cdrs=2,hungup=0;sip/5=incoming|user1|user2|1758343601-3|3,sip/6=outgoing|user1|user2|1758343601-3|3%M%J:module=cdrbuild:handlers=engine%z90,callgen%z100,moh%z100,cdrcombine%z100,rex_debug%z100,g722webrtc%z100,isaccodec%z100,cdrbuild%z100,ilbcwebrtc%z100,accfile%z100,regfile%z100,jbfeatures%z110,jabber%z110,analogdetect%z110,sigtransport%z110,subscription%z110,mgcpca%z110,hep3_capture%z110,ciscosm%z110,mux%z110,openssl%z110,javascript%z110,socks%z110,zlibcompress%z110,gvoice%z110,sip%z110,analyzer%z110,tone%z110,extmodule%z110,callfork%z110,fileinfo%z110,stun%z110,iax%z110,enumroute%z110,regexroute%z110,pbx%z110,dumb%z110,jingle%z110,wave%z110,yrtp%z110,tonedetect%z110,conf%z110,filetransfer%z110,analog%z110,sig%z110,snmpagent%z110,mgcpgw%z110,queuesnotify%z110,queues%z110,cache%z110,mrcp%z110,users%z110,presence%z110,monitoring%z110,register%z110,park%z110,sipfeatures%z110
```

So we can see the 2 cdrs (channels).
The important thing in them is the channel id ("sip/5", "sip/6") that can be used to issue exiternal commands like 'call.drop' (we need this for example to terminate all calls that might remain
alive in yate after a failed test).

## TODO

- The experiments (tests/functional/*.js files) likely are watching all messages for all calls in the system. Since this is for testing and learning, this is OK. But in a production system we would not use this and
more likely would ask yate to restrict notification for specific channels we are handling in the script.

## Programming

Yate is based on the concept of messages being published and passed to interested modules according to priority: 

https://docs.yate.ro/wiki/Messages

https://docs.yate.ro/wiki/Standard_Messages

So we can write our own modules subscribing to messages, publishing messages and handling messages passed to us by the yate engine.

Yate is written in C++ so the easiest and most efficient approach would be to write modules in C++.

However, for simple programming tasks we can just use the extmodule interface which permits an external module to talk with yate via a tcp socket.

This way, you can write apps in any language you like: 

node.js:

  https://github.com/0LEG0/next-yate/tree/master?tab=readme-ov-file#featured-ivr-example-using-yatechannel

python:

  https://github.com/eventphone/python-yate/tree/master/examples

golang:

  https://github.com/lonli078/go-yate

  https://github.com/rukavina/yatego

The yate protocol is text-based and very simple: 

https://docs.yate.ro/wiki/External_module_command_flow

So you could easily write a yate protocol module for your favorite language (or ask some LLM to do it for you).

## Deployment

Do:
```
mkdir /var/run
mkdir /var/log/yate
```

Then use this as /etc/init.d/yate:

```
#!/bin/sh

### BEGIN INIT INFO
# Provides:          yate
# Required-Start:    $local_fs $network $syslog
# Required-Stop:     $local_fs $network $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start and stop the yate daemon
# Description:       YATE is a powerful and flexible telephony engine.
### END INIT INFO

# Path to the yate executable
YATE_BIN="/usr/local/bin/yate"

# The user to run the daemon as (optional, set if needed)
# YATE_USER="yate"

# Full command-line arguments for yate
YATE_OPTS="-d -s -r -l /var/log/yate/yate.log -p /var/run/yate.pid"

# PID file path
YATE_PID="/var/run/yate.pid"

# Log file path
YATE_LOG="/var/log/yate/yate.log"

# A function that returns the PID of the running process
get_pid() {
    if [ -f "$YATE_PID" ]; then
        echo $(cat "$YATE_PID")
    fi
}

# The start function
start() {
    echo -n "Starting YATE: "
    if [ -f "$YATE_PID" ] && kill -0 $(get_pid) 2>/dev/null; then
        echo "already running."
        return 1
    fi

    # Create the log directory if it doesn't exist
    mkdir -p $(dirname "$YATE_LOG")

    # Change to the correct user if specified
    # if [ -n "$YATE_USER" ]; then
    #     su -s /bin/sh -c "$YATE_BIN $YATE_OPTS" "$YATE_USER"
    # else
        $YATE_BIN $YATE_OPTS
    # fi
    
    RETVAL=$?
    if [ $RETVAL -eq 0 ]; then
        echo "OK"
    else
        echo "failed"
    fi
    return $RETVAL
}

# The stop function
stop() {
    echo -n "Stopping YATE: "
    local pid=$(get_pid)
    if [ -z "$pid" ]; then
        echo "not running."
        return 1
    fi

    kill $pid 2>/dev/null
    RETVAL=$?
    if [ $RETVAL -eq 0 ]; then
        # Wait for the process to die
        while [ -e /proc/$pid ]; do sleep 0.1; done
        rm -f "$YATE_PID"
        echo "OK"
    else
        echo "failed"
    fi
    return $RETVAL
}

# The status function
status() {
    if [ -f "$YATE_PID" ] && kill -0 $(get_pid) 2>/dev/null; then
        echo "YATE is running with PID: $(get_pid)"
        return 0
    else
        echo "YATE is not running."
        return 1
    fi
}

# The restart function
restart() {
    stop
    start
}

# Main script logic
case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    restart)
        restart
        ;;
    status)
        status
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status}"
        exit 1
        ;;
esac

exit 0
```
For log rotation use this /etc/logrotate.d/yate:
```
/var/log/yate/yate.log {
    daily
    missingok
    rotate 7
    compress
    delaycompress
    notifempty
    create 0640 root root
    postrotate
        /bin/kill -HUP `cat /var/run/yate.pid 2>/dev/null` 2> /dev/null || true
    endscript
}
```

## Findings

### Dead calls

while load testing with sipp, the test was terminated without sending BYE to the calls and these calls stayed in the 'status cdrbuild' output. 
So these are dead calls. The sipp scenarios don't use session timers and so probably these callwill stay in yate memory forever.
This might not happen in prod as we probably have session timers there but this is not critical because we can just remove such calls periodicaly using msg 'call.drop'.

### Drop calls

Using the rmanager you can drop ongoing calls by using: drop {chan|*|all} [reason]

### MRCP support:
```
2025-09-21_07:44:59.467847 <ALL> Plugin::Plugin("mrcp",false) [0x75340b37d280]
2025-09-21_07:44:59.467862 Loaded module MRCP
```
So the module is built but the mrcp.conf.sample is nowhere to be found. So if this actually works, we would need to get configuration details from source code.

